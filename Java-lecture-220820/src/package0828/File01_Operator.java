package package0828;

public class File01_Operator {
	public static void main(String[] args) {
		// 대입 연산자, 복합 대입 연산자
		//  - 대입 연산자 : 변수에 데이터 또는 표현식의 결과 값을 저장하는 연산자
		//  - 복합 대입 연산자 : 다른 연산자와 대입 연산자를 동시에 수행하는 연산자
		//		→ 다른 연산자의 좌측 변수와 대입 연산자의 좌측 변수가
		//		  동일한 변수인 경우 복합 대입 연산자로 표현할 수 있다.
		//		→ 변수의 값을 특정 연산을 통해 새로운 결과 값으로 저장할 때 사용
		//			+=, -=, *=, /=, %=, &=, |= 
		
		// 변수 a 에 10 을 대입
		int a = 10;
		
		System.out.println("a = " + a);
		// a 의 값을 10 만큼 더한다.
		a = a + 10;
		// a = 10 + 10;
		// a = 20;
		System.out.println("a = " + a);
		
		// a 의 값을 10 만큼 더한다.
		a += 10;
		System.out.println("a = " + a);
		System.out.println("-----------------------------------------------------");
		//---------------------------------------------------------------------------
		// 증감 연산자
		//  변수에 저장된 값을 1 증가 또는 감소시키는 연산자
		//  변수만 지정하면 되기 때문에 단항 연산자
		//		++(1 증가), --(1 감소)
		//  연산자의 작성 위치에 따라 전위 증감, 후위 증감으로 나뉜다
		//	 전위 증감 : 변수 앞에 작성되며, 증가된 값을 반환
		//   후위 증감 : 변수 뒤에 작성되며, 증가되지 건의 값을 반환
		int b = 0;
		int c = 0;
		System.out.println("before");
		System.out.println("b = " + b);
		System.out.println("c = " + c);
		int prefix = ++b; // 변수 b 의 값을 1 증가, 증가된 값을 반환
		int postfix = c++; // 변수 c 의 값을 1 증가, 증가되기 전의 값을 반환
		System.out.println("after");
		System.out.println("++b = " + prefix);
		System.out.println("c++ = " + postfix);		
		System.out.println("b = " + b);
		System.out.println("c = " + c);
		
		System.out.println("(++b) * 2 = " + (++b) * 2 );
		// System.out.println("(++b) * 2 = " + (2) * 2 );
		// System.out.println("(++b) * 2 = " + 4 );
		System.out.println("(c++) * 2 = " + (c++) * 2 );
		// System.out.println("(c++) * 2 = " + 1 * 2 );
		// System.out.println("(c++) * 2 = " + 2 );
		
		
		System.out.println("-----------------------------------------------------");
		//---------------------------------------------------------------------------
		// 비교 연산자(관계 연산자)
		//  두 숫자 값의 크기를 비교하는 연산자
		//  비교 연산자의 결과 값은 true, false 이다.
		//  >, <, <=, >=, ==, !=
		//  프로그램의 흐름을 제어하기 위한 제어문에서 조건식을 만들 때 사용된다.
		//   조건식 : 조건을 표현하기 위한 식
		//			 ex) 점수가 80 점 이상인가? , 나이가 20살 인가?
		int d = 10;
		
		// d 가 10 보다 크다. d 가 10 초과
		System.out.println(d +" > 10 : " + (d > 10));
		// d 가 10 보다 크거나 같다. d 가 10 이상
		System.out.println(d + ">= 10 : " + (d >= 10));
		// d 가 10 보다 작다. d 가 10 미만
		System.out.println(d + "< 10 : " + (d < 10));
		// d 가 10 보다 작거나 같다. d 가 10 이하
		System.out.println(d + "<= 10 : " + (d <= 10));
		// d 가 10과 같다.
		System.out.println(d+ "== 10 : " + (d == 10));
		// d 가 10과 다르다.
		System.out.println(d+ "!= 10 : " + (d != 10));
		
		// 비교 연산자로는 범위를 표현할 수 없다.
		//  0 이상 100 미만의 d
		// System.out.println("10 <= " + d + " < 100 : " + (0 <= d < 100));
		//  → 문법 오류
		//  → Java 에서는 다수의 연산자를 동시에 수행하지 않기 때문에
		//    연산자에 맞지 않는 타입이 오는 것을 컴파일러가 감지
		//  → (0 <= d < 100) → (true < 100) → 비교 연산자는 논리 값을 비교할 수 없다.
		
		
		System.out.println("-----------------------------------------------------");
		//---------------------------------------------------------------------------
		// 논리 연산자
		//  - 논리 값을 연산하기 위한 연산자
		//  - 연산자의 결과 값 또한 논리 값이다.
		//  - 두 개 이상의 비교 연산을 통한 값을 하나의 값으로 연산
		//		&&, ||, !
		
		int e = 10;
		// && 연산자, AND 연산자
		//  A 이고 B, A 와 B 를 모두 만족해야한다.
		// e 가 0 이상이고 10 미만이다.
		//  → 0 <= e < 10   표현 불가능
		System.out.println("e 가 0 이상이고 10 미만이다. " + ((e >= 0) && (e < 10)));
		// System.out.println("e 가 0 이상이고 10 미만이다. " + ((true) && (false)));
		// System.out.println("e 가 0 이상이고 10 미만이다. " + (false));
		
		// || 연산자, OR 연산자
		//  A 또는 B, A 와 B 중 하나라도 만족해야한다.
		// e 가 0 이하이거나 10 이상이다.
		System.out.println("e 가 0 이하이거나 10 이상이다. " + ((e <= 0) || (e >= 10)));
		// System.out.println("e 가 0 이하이거나 10 이상이다. " + ((false) || (true)));
		// System.out.println("e 가 0 이하이거나 10 이상이다. " + (true));
		
		// ! 연산자, NOT 연산자
		//  A 가 아니다. A의 반대 값
		//  이미 구해진 논리 값의 반대 값을 이용해야하는 경우
		//  드모르간의 법칙을 이용하는 경우
		
		// e 가 짝수가 아니다.
		System.out.println("e 가 홀수다. " + !(e % 2 == 0));
		
		System.out.println("-----------------------------------------------------");
		//---------------------------------------------------------------------------
		// 조건 연산자
		//  - 조건에 따른 특정 값을 지정하여 지정된 값을 반환시키는 연산자
		//  - 조건 : 비교 연산자 또는 논리 연산자로 표현된 식
		//		조건식 ? true 일 때의 표현식 : false 일 때의 표현식
		
		// 점수가 70점 이상이면 합격, 아니면 불합격
		//  score >= 70
		//		→ true → "합격" → "Pass"
		//		→ false → "불합격" → "Fail"
		int score = -40;
		
		System.out.println("Is Pass? " + (score >= 70));
		
		// 비교 연산자의 결과 값에 따라 원하는 값으로 반환되도록 할 수 있다.
		System.out.println((score >= 70 ? "Pass" : "Fail"));
		
		// score 가 음수이면 0 으로 양수이면 score 값 그대로 저장
		score = score < 0 ? 0 : score;
		System.out.println("score = " + score);
		
		System.out.println("-----------------------------------------------------");
		//---------------------------------------------------------------------------
		// 비트 연산자
		//  - 비트 단위로 연산하는 연산자
		//  - 비트 논리 연산자
		//		: 비트 단위로 논리 연산(AND, OR, XOR, NOT)
		//  - 비트 시프트 연산자
		//		: 비트 단위로 이동 연산
		
		// 다수의 상태를 처리하기 위한 데이터들을 한 번에 관리
		
		// 20 개의 전등의 상태를 관리하기 위해
		// 20 개의 boolean 타입 변수가 아닌
		// 32bit 인 int 타입 변수 하나를 이용
		int lightState = 0b0000_0000_0000_0000_0000;
		final int LIGHT_MASK = 0b1111_1111_1111_1111_1111;
		
		// 전원 ON
		lightState = lightState | LIGHT_MASK;
		
		// 전원 OFF
		lightState = lightState & (~LIGHT_MASK);
		// ~LIGHT_MASK
		//  = 0b1111_1111_1111_0000_0000_0000_0000_0000
		//    0b0100_1100_0110_0000_0000_0000_0000_0000
		
		// n 번째 전등 ON
		int lightNum = 5;
		
		int lightN = 1 << (lightNum - 1);
		// = 0b0001_0000
		lightState = lightState | lightN;
		
		// n 번째 전등 OFF
		lightState = lightState & (~lightN);
		// ~lightN = 0b1110_1111
		
		// Toggle → on/off
		//  N번째 전등이 ON 이면 OFF, OFF 이면 ON
		lightState = lightState ^ lightN;
		// lightN = 0b0001_0000
		
		System.out.println("-----------------------------------------------------");
		//---------------------------------------------------------------------------
		
	}
}
